import streamlit as st
import subprocess
import os
import tempfile
import shutil
import mimetypes
import zipfile
import io
import time
from pathlib import Path

# Page config
st.set_page_config(page_title="üé® Universal Media Converter", layout="wide")

# Custom CSS styling
st.markdown(
    """
    <style>
    body {
        background-color: #0f2027;
        background-image: linear-gradient(315deg, #2c5364 0%, #203a43 50%, #0f2027 100%);
        color: #f5f5f5;
    }
    .stButton>button {
        background: linear-gradient(90deg, #ff7e5f, #feb47b);
        color: white;
        border-radius: 8px;
        padding: 0.6em 1.2em;
        font-weight: bold;
        border: none;
    }
    .stDownloadButton>button {
        background: linear-gradient(90deg, #43cea2, #185a9d);
        color: white;
        border-radius: 8px;
        padding: 0.6em 1.2em;
        font-weight: bold;
        border: none;
    }
    h1, h2, h3 {
        text-align: center;
        color: #ffffff;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.6);
    }
    .stSpinner > div { color: white; }
    </style>
    """,
    unsafe_allow_html=True,
)

st.markdown("<h1>üé¨ Universal Media Converter</h1>", unsafe_allow_html=True)
st.caption("Easily convert video & audio files to different formats ‚Äî with style ‚ú®")
st.sidebar.markdown("## ‚öôÔ∏è Conversion Settings")
st.sidebar.info("Files are streamed to disk to avoid high memory usage. Converted files are temporary and auto-cleaned.")

# ==================== AUTO CLEANUP ====================
TEMP_DIR = Path(tempfile.gettempdir())
PREFIX = "converter_tmp_"

def auto_cleanup(threshold_minutes: int = 10) -> int:
    """Remove temp files created by this app older than threshold_minutes.
    Returns number of removed files."""
    now = time.time()
    removed = 0
    for p in TEMP_DIR.glob(PREFIX + "*"):
        try:
            age_minutes = (now - p.stat().st_mtime) / 60
            if age_minutes > threshold_minutes:
                p.unlink()
                removed += 1
        except Exception:
            pass
    return removed

removed_count = auto_cleanup(10)
if removed_count > 0:
    st.sidebar.success(f"üßπ Auto-cleaned {removed_count} old temp file(s)")

# ======================================================

# Check ffmpeg availability
from shutil import which
ffmpeg_path = which("ffmpeg")
if ffmpeg_path is None:
    st.error(
        "‚ö†Ô∏è FFmpeg binary not found on the server. "
        "If you're running this on your own machine, install ffmpeg (macOS: `brew install ffmpeg`, Ubuntu: `sudo apt install ffmpeg`). "
        "If you deploy to Streamlit Cloud, the cloud environment should include ffmpeg or allow installing it."
    )
    st.stop()

# Uploader and options
uploaded_files = st.file_uploader("üìÇ Upload your files (multiple)", accept_multiple_files=True, type=None)
formats = ["mp4", "mp3", "mkv", "mov", "avi", "flv", "wmv", "wav", "aac", "ogg", "amv"]
output_format = st.sidebar.selectbox("üéØ Output format", formats, index=0)

presets = {
    "Default": [],
    "üì± Mobile (low res)": ["-vf", "scale=640:-2", "-b:v", "600k", "-preset", "fast"],
    "üéûÔ∏è High Quality": ["-b:v", "3000k", "-preset", "slow"]
}
preset_choice = st.sidebar.radio("Preset", list(presets.keys()))

def save_upload_to_disk(uploaded, dest_path: str):
    """Stream uploaded file to disk in chunks to avoid reading whole file into memory."""
    uploaded.seek(0)
    with open(dest_path, "wb") as f:
        shutil.copyfileobj(uploaded, f, length=2**20)  # 1MB chunks

def run_ffmpeg_disk_to_disk(in_path: str, out_path: str, extra_args=None):
    extra_args = extra_args or []
    cmd = [ffmpeg_path, "-y", "-i", in_path] + extra_args + [out_path]
    completed = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    if completed.returncode != 0:
        stderr = completed.stderr.decode(errors="ignore")
        raise RuntimeError(f"FFmpeg failed (returncode={completed.returncode}):\n{stderr}")

if uploaded_files:
    converted = []
    for uploaded in uploaded_files:
        st.subheader(f"üìÄ {uploaded.name}")
        # Save upload to disk with prefix so auto-cleanup can find it
        suffix = os.path.splitext(uploaded.name)[1] or ""
        in_tmp = tempfile.NamedTemporaryFile(delete=False, prefix=PREFIX, suffix=suffix)
        in_tmp_path = in_tmp.name
        in_tmp.close()
        try:
            with st.spinner("Saving upload to disk..."):
                save_upload_to_disk(uploaded, in_tmp_path)
        except Exception as e:
            st.error(f"Failed saving upload: {e}")
            if os.path.exists(in_tmp_path):
                os.remove(in_tmp_path)
            continue

        # Prepare output temp file
        out_tmp = tempfile.NamedTemporaryFile(delete=False, prefix=PREFIX, suffix="." + output_format)
        out_tmp_path = out_tmp.name
        out_tmp.close()

        with st.spinner(f"Converting to .{output_format}..."):
            try:
                run_ffmpeg_disk_to_disk(in_tmp_path, out_tmp_path, extra_args=presets.get(preset_choice, []))
                size = os.path.getsize(out_tmp_path)
                st.success(f"‚úÖ Done! Output: {os.path.basename(out_tmp_path)} ‚Äî {size/1024/1024:.2f} MB")
                converted.append((uploaded.name, in_tmp_path, out_tmp_path))

                # Provide download button (reads file when user clicks)
                mime = mimetypes.guess_type(out_tmp_path)[0] or "application/octet-stream"
                with open(out_tmp_path, "rb") as f:
                    st.download_button(label=f"‚¨áÔ∏è Download {os.path.basename(out_tmp_path)}", data=f.read(), file_name=os.path.basename(out_tmp_path), mime=mime)
            except Exception as e:
                st.error(f"‚ùå Conversion failed: {e}")
                # cleanup on failure
                if os.path.exists(out_tmp_path):
                    os.remove(out_tmp_path)
                if os.path.exists(in_tmp_path):
                    os.remove(in_tmp_path)

    # ZIP all converted files (if any)
    if converted:
        zip_buf = io.BytesIO()
        with zipfile.ZipFile(zip_buf, "w", zipfile.ZIP_DEFLATED) as zf:
            for orig_name, in_path, out_path in converted:
                arcname = os.path.splitext(orig_name)[0] + "." + output_format
                zf.write(out_path, arcname=arcname)
        st.download_button("üì¶ Download all converted files (ZIP)", data=zip_buf.getvalue(), file_name="converted_files.zip", mime="application/zip")

    # Manual cleanup button
    if st.button("üßπ Cleanup temporary files now"):
        removed = 0
        for orig_name, in_path, out_path in converted:
            for pth in (in_path, out_path):
                try:
                    if os.path.exists(pth):
                        os.remove(pth)
                        removed += 1
                except Exception:
                    pass
        st.info(f"Removed {removed} temporary files.")
else:
    st.info("‚¨ÜÔ∏è Upload one or more files to start converting.")